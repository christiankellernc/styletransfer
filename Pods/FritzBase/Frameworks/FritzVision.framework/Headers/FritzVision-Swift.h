#if TARGET_OS_SIMULATOR
#if 0
#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.0 (swiftlang-1001.0.69.5 clang-1001.0.46.3)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import CoreMedia;
@import CoreVideo;
@import ImageIO;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="FritzVision",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class FritzManagedModel;
@class FritzMLModel;

SWIFT_CLASS("_TtC11FritzVision13BasePredictor") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface BasePredictor : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize model with FritzMLModel
/// \param model FritzMLModel
///
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
/// Initialize model with FritzMLModel
/// \param model FritzMLModel
///
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// BoundingBox Contains coordinates to draw bounding boxes on images as predicted directly by the model.  However, because of cropping or resizing done to accomadate model size constraints, the default values may not map to coordinates in your view.  Use the toCGRect functions to convert bounding box coordinates to fit the image.
SWIFT_CLASS_NAMED("BoundingBox")
@interface BoundingBox : NSObject
- (nonnull instancetype)initWithYMin:(double)yMin xMin:(double)xMin yMax:(double)yMax xMax:(double)xMax OBJC_DESIGNATED_INITIALIZER;
- (CGRect)imgHeight:(double)imgHeight imgWidth:(double)imgWidth SWIFT_WARN_UNUSED_RESULT;
- (CGRect)imgHeight:(double)imgHeight imgWidth:(double)imgWidth xOffset:(double)xOffset yOffset:(double)yOffset SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CALayer;
@class UIColor;

SWIFT_CLASS_NAMED("BoundingBoxOutline")
@interface BoundingBoxOutline : NSObject
/// Add shape and text to parent layer
/// \param parent parent CALayer
///
- (void)parent:(CALayer * _Nonnull)parent;
/// Show Bounding box.
/// \param frame CGRect of coordinates to draw box
///
/// \param label Classified label
///
/// \param color Color of bounding box outline
///
/// \param textColor Classified label text
///
- (void)frame:(CGRect)frame label:(NSString * _Nonnull)label color:(UIColor * _Nonnull)color textColor:(UIColor * _Nonnull)textColor;
/// Hide bounding box from appearing in view.
- (void)hide;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("FlexibleModelDimensions")
@interface FlexibleModelDimensions : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithSize:(CGSize)size OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithWidth:(NSInteger)width withHeight:(NSInteger)height OBJC_DESIGNATED_INITIALIZER;
@end


@interface FlexibleModelDimensions (SWIFT_EXTENSION(FritzVision))
/// Use original image dimensions.  Model will throw an error if image dimensions are not within range of acceptable input sizes.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull original;)
+ (FlexibleModelDimensions * _Nonnull)original SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull lowResolution;)
+ (FlexibleModelDimensions * _Nonnull)lowResolution SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull mediumResolution;)
+ (FlexibleModelDimensions * _Nonnull)mediumResolution SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull highResolution;)
+ (FlexibleModelDimensions * _Nonnull)highResolution SWIFT_WARN_UNUSED_RESULT;
@end

/// Describes the orientation of the image. The orientations match the <a href="https://developer.apple.com/documentation/imageio/cgimagepropertyorientation">CGImagePropertyOrientation</a> Enumeration from Apple. Refer to that documentation for clear descriptions of each case.
typedef SWIFT_ENUM(int32_t, FritzImageOrientation, closed) {
  FritzImageOrientationUp = 1,
  FritzImageOrientationUpMirrored = 2,
  FritzImageOrientationDown = 3,
  FritzImageOrientationDownMirrored = 4,
  FritzImageOrientationLeftMirrored = 5,
  FritzImageOrientationRight = 6,
  FritzImageOrientationRightMirrored = 7,
  FritzImageOrientationLeft = 8,
};

typedef SWIFT_ENUM_NAMED(NSInteger, FritzVisionCropAndScale, "FritzVisionCropAndScale", closed) {
  FritzVisionCropAndScaleCenterCrop = 1,
  FritzVisionCropAndScaleScaleFill = 2,
  FritzVisionCropAndScaleScaleFit = 3,
};

typedef SWIFT_ENUM(NSInteger, FritzVisionError, closed) {
  FritzVisionErrorInvalidSampleImageBuffer = 0,
  FritzVisionErrorErrorProcessingImage = 1,
};
static NSString * _Nonnull const FritzVisionErrorDomain = @"FritzVision.FritzVisionError";

@protocol FritzSwiftIdentifiedModel;
@class FritzVisionImage;
@class FritzVisionFlexibleStyleModelOptions;

/// Construct a Flexible Style Transfer model and run on any FritzVisionImage. Use this class over <code>FritzVisionStyleTransferModel</code> to produce stylized images with customizable output sizes.
SWIFT_CLASS_NAMED("FritzVisionFlexibleStyleModel") SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model;
/// Initialize FritzVisionFlexibleStyleModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Initialize FritzVisionFlexibleStyleModel with your own trained style model.
/// \param model Fritz model to use.
///
/// \param managedModel FritzManagedModel to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Run Style Transfer on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionFlexibleStyleModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(CVPixelBufferRef _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel (SWIFT_EXTENSION(FritzVision))
/// Fetch and load Style Models for the given tags.
/// Note that this instantiates all models which could cause memory pressure if you are loading many models.
/// If you do not want to immediately instantiate the models, create a ModelTagManager and manage loading yourself.
/// \param tags List of tags to load models for.
///
/// \param wifiRequiredForModelDownload If true, client must be connected to a wifi network to download a model. Default is false.
///
/// \param completionHandler Completion handler with instantiated FritzVisionStyleModels
///
+ (void)fetchStyleModelsForTags:(NSArray<NSString *> * _Nonnull)tags wifiRequiredForModelDownload:(BOOL)wifiRequiredForModelDownload withCompletionHandler:(void (^ _Nonnull)(NSArray<FritzVisionFlexibleStyleModel *> * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


/// Options for how to run flexible style transfer model.
SWIFT_CLASS_NAMED("FritzVisionFlexibleStyleModelOptions")
@interface FritzVisionFlexibleStyleModelOptions : NSObject
/// Crop and scale option. Default option is .scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Set dimensions for output result of flexible model.
@property (nonatomic, strong) FlexibleModelDimensions * _Nonnull flexibleModelDimensions;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class UIImage;

/// An image or image buffer used in vision detection.
SWIFT_CLASS_NAMED("FritzVisionImage") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionImage : NSObject
- (nonnull instancetype)initWithBuffer:(CMSampleBufferRef _Nonnull)buffer OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImageBuffer:(CVPixelBufferRef _Nonnull)imageBuffer OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImage:(UIImage * _Nonnull)image OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionImage (SWIFT_EXTENSION(FritzVision))
- (CVPixelBufferRef _Nullable)rotate SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS_NAMED("FritzVisionImageMetadata")
@interface FritzVisionImageMetadata : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Orientation defaults to <code>FritzImageOrientation.right</code> which should work for rear facing cameras with a device orientation of Portrait.
@property (nonatomic) enum FritzImageOrientation orientation;
@property (nonatomic, readonly) CGImagePropertyOrientation cgOrientation;
@end


/// Represents a label for an image.
SWIFT_CLASS_NAMED("FritzVisionLabel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionLabel : NSObject
/// Human readable string of detected label.
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
/// Prediction confidence for label in range of [0, 1]
@property (nonatomic, readonly) double confidence;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithLabel:(NSString * _Nonnull)label confidence:(double)confidence OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, FritzVisionLabelError, closed) {
  FritzVisionLabelErrorNoVisionModel = 0,
};
static NSString * _Nonnull const FritzVisionLabelErrorDomain = @"FritzVision.FritzVisionLabelError";

@class FritzModelConfiguration;
@class FritzVisionLabelModelOptions;

SWIFT_CLASS_NAMED("FritzVisionLabelModel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionLabelModel : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
+ (void)setModelConfig:(FritzModelConfiguration * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
/// Run label prediction requst on a UIImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains an array of FritzVisionLabel objects or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionLabelModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<FritzVisionLabel *> * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLabelModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionLabelModel * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLabelModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionLabelModelOptions")
@interface FritzVisionLabelModelOptions : NSObject
/// Confidence threshold for prediction results in the range of [0, 1], default is 0.6.
@property (nonatomic) double threshold;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic, readonly) BOOL forceCoreMLPrediction;
/// Number of results to return from request.
@property (nonatomic) NSInteger numResults;
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class ModelSegmentationClass;

SWIFT_CLASS_NAMED("FritzVisionLivingRoomClass")
@interface FritzVisionLivingRoomClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull chair;)
+ (ModelSegmentationClass * _Nonnull)chair SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull wall;)
+ (ModelSegmentationClass * _Nonnull)wall SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull coffeeTable;)
+ (ModelSegmentationClass * _Nonnull)coffeeTable SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull ceiling;)
+ (ModelSegmentationClass * _Nonnull)ceiling SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull floor;)
+ (ModelSegmentationClass * _Nonnull)floor SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bed;)
+ (ModelSegmentationClass * _Nonnull)bed SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull lamp;)
+ (ModelSegmentationClass * _Nonnull)lamp SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sofa;)
+ (ModelSegmentationClass * _Nonnull)sofa SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull windowpane;)
+ (ModelSegmentationClass * _Nonnull)windowpane SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull pillow;)
+ (ModelSegmentationClass * _Nonnull)pillow SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzVisionSegmentationModelOptions;
@class FritzVisionSegmentationResult;

SWIFT_CLASS_NAMED("FritzVisionSegmentationModel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionSegmentationModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
@property (nonatomic, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull classes;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes;
/// Run image segmentation on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionSegmentationModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzVisionSegmentationResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Image segmentation model to detect common living room objects.
SWIFT_CLASS_NAMED("FritzVisionLivingRoomSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLivingRoomSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionLivingRoomSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionObject") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObject : NSObject
@property (nonatomic, readonly, strong) FritzVisionLabel * _Nonnull detectedLabel;
/// BoundingBox of detected object.
@property (nonatomic, readonly, strong) BoundingBox * _Nonnull boundingBox;
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
@property (nonatomic, readonly) double confidence;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithLabel:(FritzVisionLabel * _Nonnull)label boundingBox:(BoundingBox * _Nonnull)boundingBox OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("FritzVisionObjectModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionObjectModel * _Nullable, NSError * _Nullable))completionHandler;
@end

@class FritzVisionObjectModelOptions;

SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Run prediction for vision object model.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request has finished processing.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionObjectModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<FritzVisionObject *> * _Nullable, NSError * _Nullable))completion;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionObjectModelOptions")
@interface FritzVisionObjectModelOptions : NSObject
/// Confidence threshold for prediction results in the range of [0, 1], default is 0.6.
@property (nonatomic) double threshold;
/// Threshold for overlap of items within a single class in range [0, 1].  Lower values are more strict.
@property (nonatomic) float iouThreshold;
/// Number of results to return from request.
@property (nonatomic) NSInteger numResults;
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic, readonly) BOOL forceCoreMLPrediction;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionOutdoorClass")
@interface FritzVisionOutdoorClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull building;)
+ (ModelSegmentationClass * _Nonnull)building SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sky;)
+ (ModelSegmentationClass * _Nonnull)sky SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull tree;)
+ (ModelSegmentationClass * _Nonnull)tree SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sidewalk;)
+ (ModelSegmentationClass * _Nonnull)sidewalk SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull ground;)
+ (ModelSegmentationClass * _Nonnull)ground SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull car;)
+ (ModelSegmentationClass * _Nonnull)car SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull water;)
+ (ModelSegmentationClass * _Nonnull)water SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull house;)
+ (ModelSegmentationClass * _Nonnull)house SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull fence;)
+ (ModelSegmentationClass * _Nonnull)fence SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sign;)
+ (ModelSegmentationClass * _Nonnull)sign SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull skyscraper;)
+ (ModelSegmentationClass * _Nonnull)skyscraper SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bridge;)
+ (ModelSegmentationClass * _Nonnull)bridge SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull river;)
+ (ModelSegmentationClass * _Nonnull)river SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bus;)
+ (ModelSegmentationClass * _Nonnull)bus SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull truck;)
+ (ModelSegmentationClass * _Nonnull)truck SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull van;)
+ (ModelSegmentationClass * _Nonnull)van SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull motorbike;)
+ (ModelSegmentationClass * _Nonnull)motorbike SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bicycle;)
+ (ModelSegmentationClass * _Nonnull)bicycle SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull trafficLight;)
+ (ModelSegmentationClass * _Nonnull)trafficLight SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect common outdoor objects.
SWIFT_CLASS_NAMED("FritzVisionOutdoorSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionOutdoorSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionOutdoorSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Class labels for FritzVisionPeopleSegmentationModel
SWIFT_CLASS_NAMED("FritzVisionPeopleClass")
@interface FritzVisionPeopleClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationMediumClass")
@interface FritzVisionPeopleSegmentationMediumClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect people.
SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationMediumModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPeopleSegmentationMediumModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPeopleSegmentationMediumModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect people.
SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPeopleSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPeopleSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Model used to create a 3D pose from 2D pose
SWIFT_CLASS_NAMED("FritzVisionPoseLiftingModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseLiftingModel : BasePredictor
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzPose;
@class PoseLiftingPredictorOptions;
@class FritzPose3D;

SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseLiftingModel (SWIFT_EXTENSION(FritzVision))
/// Predict poses from an inputPose
/// \param input Input pose to process.
///
/// \param options The options used to configure the pose results.
///
/// \param completion Handler to call back on the main thread with poses or error.
///
- (void)predictWithImage:(FritzPose * _Nonnull)input options:(PoseLiftingPredictorOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzPose3D * _Nullable, NSError * _Nullable))completion;
@end

@class FritzVisionPoseModelOptions;
@class FritzVisionPoseResult;

/// A model used to predict the poses of people in images.
SWIFT_CLASS_NAMED("FritzVisionPoseModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseModel : BasePredictor
/// Model Configuration for pose model in Fritz.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
+ (void)setModelConfig:(FritzModelConfiguration * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
/// Is WiFi required to download pose model over the air.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Predict poses from a FritzImage.
/// \param input The image to use to dectect poses.
///
/// \param options The options used to configure the pose results.
///
/// \param completion Handler to call back on the main thread with poses or error.
///
- (void)predictWithImage:(FritzVisionImage * _Nonnull)input options:(FritzVisionPoseModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzVisionPoseResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPoseModel * _Nullable, NSError * _Nullable))completionHandler;
@end


/// Options for Pose Model.
SWIFT_CLASS_NAMED("FritzVisionPoseModelOptions")
@interface FritzVisionPoseModelOptions : NSObject
/// Crop and scale option. Default value is scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Minimum score a part must have to be included in a pose.
@property (nonatomic) double minPartThreshold;
/// Minimum score a pose must have to be included in results.
@property (nonatomic) double minPoseThreshold;
/// NMS radius for pose
@property (nonatomic) NSInteger nmsRadius;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@protocol MLFeatureProvider;

SWIFT_CLASS_NAMED("FritzVisionPoseResult") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseResult : NSObject
/// Model image width
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger modelInputWidth;)
+ (NSInteger)modelInputWidth SWIFT_WARN_UNUSED_RESULT;
/// Model image height
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger modelInputHeight;)
+ (NSInteger)modelInputHeight SWIFT_WARN_UNUSED_RESULT;
/// Original input image before it was rescaled
@property (nonatomic, readonly, strong) FritzVisionImage * _Nonnull image;
/// Pose model options.
@property (nonatomic, readonly, strong) FritzVisionPoseModelOptions * _Nonnull options;
/// Unavailable.  Use <code>FritzVisionPoseModel.predict</code> function to build.
- (nonnull instancetype)initForResults:(id <MLFeatureProvider> _Nonnull)results fritzImage:(FritzVisionImage * _Nonnull)fritzImage options:(FritzVisionPoseModelOptions * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseResult (SWIFT_EXTENSION(FritzVision))
/// Decode single pose result
///
/// returns:
/// Pose
- (FritzPose * _Nullable)decodePose SWIFT_WARN_UNUSED_RESULT;
/// Draw single pose on input image.
///
/// returns:
/// UIImage if pose detected.
- (UIImage * _Nullable)drawPose SWIFT_WARN_UNUSED_RESULT;
/// Draw detected poses on input image.
/// \param pose List of poses to draw
///
///
/// returns:
/// Original image with poses drawn on image.
- (UIImage * _Nullable)drawPose:(FritzPose * _Nonnull)pose SWIFT_WARN_UNUSED_RESULT;
@end



SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionSegmentationModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionSegmentationModelOptions")
@interface FritzVisionSegmentationModelOptions : NSObject
/// Crop and scale option. Default value is scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class MLMultiArray;

SWIFT_CLASS_NAMED("FritzVisionSegmentationResult") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionSegmentationResult : NSObject
/// Height of model output array.
@property (nonatomic, readonly) NSInteger height;
/// Width of model output array.
@property (nonatomic, readonly) NSInteger width;
/// Model classes.
@property (nonatomic, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull classes;
/// Raw MLMultiArray result from prediction.
@property (nonatomic, readonly, strong) MLMultiArray * _Nonnull predictionResult;
/// Create 2D-Array same size as the model output with each point representing most likely class.
/// \param minThreshold Only include classes that have a probability greater than the minThreshold.
///
- (NSArray<NSNumber *> * _Nonnull)getMaxIndices:(double)minThreshold SWIFT_WARN_UNUSED_RESULT;
/// Generate UIImage mask from most likely class at each pixel.
/// The generated image size will fit the original image passed into prediction, applying rotation.  If the image was center cropped, will return an image that covers the cropped image.
/// \param minThreshold Minimum threshold value needed to count. By default zero.  You can set this property to filter out classes that may be the most likely but still have a lower probability.
///
/// \param alpha Alpha value of the color (0-255) for detected classes. By default completely opaque.
///
- (UIImage * _Nullable)toImageMask:(double)minThreshold alpha:(uint8_t)alpha SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSNumber *> * _Nonnull)thresholdClass:(ModelSegmentationClass * _Nonnull)segmentClass threshold:(double)threshold minAccepted:(double)minAccepted SWIFT_WARN_UNUSED_RESULT;
/// Generate UIImage mask of given class, filtering out values below threshold.
/// The generated image size will fit the original image passed into prediction, applying rotation.  If the image was center cropped, will return an image that covers the cropped image.
/// \param segmentClass Class to mask.
///
/// \param threshold Probability to filter.  Any probabilities below this value will be filtered out.
///
/// \param alpha Alpha value of the color (0-255) for detected classes.
///
/// \param minThresholdAccepted Any confidence score below this value will have an alpha of 0. Class confidence scores between <code>minThresholdAccepted</code> and <code>threshold</code> will retain their original value.
///
- (UIImage * _Nullable)toImageMask:(ModelSegmentationClass * _Nonnull)segmentClass threshold:(double)threshold alpha:(uint8_t)alpha minThresholdAccepted:(double)minThresholdAccepted SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class FritzVisionStyleModelOptions;

SWIFT_CLASS_NAMED("FritzVisionStyleModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model error:(NSError * _Nullable * _Nullable)error;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
/// \param managedModel ManagedModel to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Run Style Transfer on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionStyleModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(CVPixelBufferRef _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel (SWIFT_EXTENSION(FritzVision))
/// Fetch and load Style Models for the given tags.
/// Note that this instantiates all models which could cause memory pressure if you are loading many models.
/// If you do not want to immediately instantiate the models, create a ModelTagManager and manage loading yourself.
/// \param tags List of tags to load models for.
///
/// \param wifiRequiredForModelDownload If true, client must be connected to a wifi network to download a model. Default is false.
///
/// \param completionHandler Completion handler with instantiated FritzVisionStyleModels
///
+ (void)fetchStyleModelsForTags:(NSArray<NSString *> * _Nonnull)tags wifiRequiredForModelDownload:(BOOL)wifiRequiredForModelDownload withCompletionHandler:(void (^ _Nonnull)(NSArray<FritzVisionStyleModel *> * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionStyleModelOptions")
@interface FritzVisionStyleModelOptions : NSObject
/// Crop and scale option.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Resize the output to match the FritzVisionImage size.
@property (nonatomic) BOOL resizeOutputToInputDimensions;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzPosePoint;
enum PosePart : NSInteger;

/// Predicted keypoint containing part, score, and position identified.
SWIFT_CLASS_NAMED("Keypoint")
@interface FritzPoseKeypoint : NSObject
@property (nonatomic, readonly) NSInteger id;
@property (nonatomic, readonly, strong) FritzPosePoint * _Nonnull position;
@property (nonatomic, readonly) double score;
@property (nonatomic, readonly) enum PosePart part;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class Point3D;

/// Predicted keypoint containing part, score, and position identified.
SWIFT_CLASS_NAMED("Keypoint3D")
@interface FritzPoseKeypoint3D : NSObject
@property (nonatomic, readonly) NSInteger id;
@property (nonatomic, readonly, strong) Point3D * _Nonnull position;
@property (nonatomic, readonly) double score;
@property (nonatomic, readonly) enum PosePart part;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("ModelSegmentationClass")
@interface ModelSegmentationClass : NSObject
/// Index in output array from model.
@property (nonatomic, readonly) NSInteger index;
/// Label name for Model Segmentation Class.
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Predicted point on model input coordinates.
SWIFT_CLASS_NAMED("Point")
@interface FritzPosePoint : NSObject
@property (nonatomic, readonly) double x;
@property (nonatomic, readonly) double y;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end
















SWIFT_CLASS("_TtC11FritzVision7Point3D")
@interface Point3D : NSObject
@property (nonatomic, readonly) double x;
@property (nonatomic, readonly) double y;
@property (nonatomic, readonly) double z;
- (nonnull instancetype)initWithX:(double)x y:(double)y z:(double)z OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (NSArray<NSNumber *> * _Nonnull)toArray SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface Point3D (SWIFT_EXTENSION(FritzVision))
- (nonnull instancetype)initWith:(NSArray<NSNumber *> * _Nonnull)array;
@end






/// Detected pose with Keypoints and corresponding score.
SWIFT_CLASS_NAMED("Pose") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzPose : NSObject
@property (nonatomic, readonly, copy) NSArray<FritzPoseKeypoint *> * _Nonnull keypoints;
@property (nonatomic, readonly) double score;
/// Create new Pose with keypoint positions scaled to be inside of rect.
/// \param rect Rect coordinates
///
///
/// returns:
/// New Pose with position inset in provided rect
- (FritzPose * _Nonnull)inRect:(CGRect)rect SWIFT_WARN_UNUSED_RESULT;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end






/// Detected pose with Keypoints and corresponding score.
SWIFT_CLASS_NAMED("Pose3D") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzPose3D : NSObject
@property (nonatomic, readonly, copy) NSArray<FritzPoseKeypoint3D *> * _Nonnull keypoints;
@property (nonatomic, readonly) double score;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end






/// Options for Pose Model.
SWIFT_CLASS("_TtC11FritzVision27PoseLiftingPredictorOptions")
@interface PoseLiftingPredictorOptions : NSObject
/// Default Pose model options.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) PoseLiftingPredictorOptions * _Nonnull defaults;)
+ (PoseLiftingPredictorOptions * _Nonnull)defaults SWIFT_WARN_UNUSED_RESULT;
/// If true only uses CPU to run predictions.
@property (nonatomic) BOOL useCPUOnly;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, PosePart, closed) {
  PosePartNose = 0,
  PosePartLeftEye = 1,
  PosePartRightEye = 2,
  PosePartLeftEar = 3,
  PosePartRightEar = 4,
  PosePartLeftShoulder = 5,
  PosePartRightShoulder = 6,
  PosePartLeftElbow = 7,
  PosePartRightElbow = 8,
  PosePartLeftWrist = 9,
  PosePartRightWrist = 10,
  PosePartLeftHip = 11,
  PosePartRightHip = 12,
  PosePartLeftKnee = 13,
  PosePartRightKnee = 14,
  PosePartLeftAnkle = 15,
  PosePartRightAnkle = 16,
};





#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__i386__) && __i386__
// Generated by Apple Swift version 5.0 (swiftlang-1001.0.69.5 clang-1001.0.46.3)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import CoreMedia;
@import CoreVideo;
@import ImageIO;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="FritzVision",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class FritzManagedModel;
@class FritzMLModel;

SWIFT_CLASS("_TtC11FritzVision13BasePredictor") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface BasePredictor : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize model with FritzMLModel
/// \param model FritzMLModel
///
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
/// Initialize model with FritzMLModel
/// \param model FritzMLModel
///
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// BoundingBox Contains coordinates to draw bounding boxes on images as predicted directly by the model.  However, because of cropping or resizing done to accomadate model size constraints, the default values may not map to coordinates in your view.  Use the toCGRect functions to convert bounding box coordinates to fit the image.
SWIFT_CLASS_NAMED("BoundingBox")
@interface BoundingBox : NSObject
- (nonnull instancetype)initWithYMin:(double)yMin xMin:(double)xMin yMax:(double)yMax xMax:(double)xMax OBJC_DESIGNATED_INITIALIZER;
- (CGRect)imgHeight:(double)imgHeight imgWidth:(double)imgWidth SWIFT_WARN_UNUSED_RESULT;
- (CGRect)imgHeight:(double)imgHeight imgWidth:(double)imgWidth xOffset:(double)xOffset yOffset:(double)yOffset SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CALayer;
@class UIColor;

SWIFT_CLASS_NAMED("BoundingBoxOutline")
@interface BoundingBoxOutline : NSObject
/// Add shape and text to parent layer
/// \param parent parent CALayer
///
- (void)parent:(CALayer * _Nonnull)parent;
/// Show Bounding box.
/// \param frame CGRect of coordinates to draw box
///
/// \param label Classified label
///
/// \param color Color of bounding box outline
///
/// \param textColor Classified label text
///
- (void)frame:(CGRect)frame label:(NSString * _Nonnull)label color:(UIColor * _Nonnull)color textColor:(UIColor * _Nonnull)textColor;
/// Hide bounding box from appearing in view.
- (void)hide;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("FlexibleModelDimensions")
@interface FlexibleModelDimensions : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithSize:(CGSize)size OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithWidth:(NSInteger)width withHeight:(NSInteger)height OBJC_DESIGNATED_INITIALIZER;
@end


@interface FlexibleModelDimensions (SWIFT_EXTENSION(FritzVision))
/// Use original image dimensions.  Model will throw an error if image dimensions are not within range of acceptable input sizes.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull original;)
+ (FlexibleModelDimensions * _Nonnull)original SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull lowResolution;)
+ (FlexibleModelDimensions * _Nonnull)lowResolution SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull mediumResolution;)
+ (FlexibleModelDimensions * _Nonnull)mediumResolution SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull highResolution;)
+ (FlexibleModelDimensions * _Nonnull)highResolution SWIFT_WARN_UNUSED_RESULT;
@end

/// Describes the orientation of the image. The orientations match the <a href="https://developer.apple.com/documentation/imageio/cgimagepropertyorientation">CGImagePropertyOrientation</a> Enumeration from Apple. Refer to that documentation for clear descriptions of each case.
typedef SWIFT_ENUM(int32_t, FritzImageOrientation, closed) {
  FritzImageOrientationUp = 1,
  FritzImageOrientationUpMirrored = 2,
  FritzImageOrientationDown = 3,
  FritzImageOrientationDownMirrored = 4,
  FritzImageOrientationLeftMirrored = 5,
  FritzImageOrientationRight = 6,
  FritzImageOrientationRightMirrored = 7,
  FritzImageOrientationLeft = 8,
};

typedef SWIFT_ENUM_NAMED(NSInteger, FritzVisionCropAndScale, "FritzVisionCropAndScale", closed) {
  FritzVisionCropAndScaleCenterCrop = 1,
  FritzVisionCropAndScaleScaleFill = 2,
  FritzVisionCropAndScaleScaleFit = 3,
};

typedef SWIFT_ENUM(NSInteger, FritzVisionError, closed) {
  FritzVisionErrorInvalidSampleImageBuffer = 0,
  FritzVisionErrorErrorProcessingImage = 1,
};
static NSString * _Nonnull const FritzVisionErrorDomain = @"FritzVision.FritzVisionError";

@protocol FritzSwiftIdentifiedModel;
@class FritzVisionImage;
@class FritzVisionFlexibleStyleModelOptions;

/// Construct a Flexible Style Transfer model and run on any FritzVisionImage. Use this class over <code>FritzVisionStyleTransferModel</code> to produce stylized images with customizable output sizes.
SWIFT_CLASS_NAMED("FritzVisionFlexibleStyleModel") SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model;
/// Initialize FritzVisionFlexibleStyleModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Initialize FritzVisionFlexibleStyleModel with your own trained style model.
/// \param model Fritz model to use.
///
/// \param managedModel FritzManagedModel to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Run Style Transfer on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionFlexibleStyleModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(CVPixelBufferRef _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel (SWIFT_EXTENSION(FritzVision))
/// Fetch and load Style Models for the given tags.
/// Note that this instantiates all models which could cause memory pressure if you are loading many models.
/// If you do not want to immediately instantiate the models, create a ModelTagManager and manage loading yourself.
/// \param tags List of tags to load models for.
///
/// \param wifiRequiredForModelDownload If true, client must be connected to a wifi network to download a model. Default is false.
///
/// \param completionHandler Completion handler with instantiated FritzVisionStyleModels
///
+ (void)fetchStyleModelsForTags:(NSArray<NSString *> * _Nonnull)tags wifiRequiredForModelDownload:(BOOL)wifiRequiredForModelDownload withCompletionHandler:(void (^ _Nonnull)(NSArray<FritzVisionFlexibleStyleModel *> * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


/// Options for how to run flexible style transfer model.
SWIFT_CLASS_NAMED("FritzVisionFlexibleStyleModelOptions")
@interface FritzVisionFlexibleStyleModelOptions : NSObject
/// Crop and scale option. Default option is .scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Set dimensions for output result of flexible model.
@property (nonatomic, strong) FlexibleModelDimensions * _Nonnull flexibleModelDimensions;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class UIImage;

/// An image or image buffer used in vision detection.
SWIFT_CLASS_NAMED("FritzVisionImage") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionImage : NSObject
- (nonnull instancetype)initWithBuffer:(CMSampleBufferRef _Nonnull)buffer OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImageBuffer:(CVPixelBufferRef _Nonnull)imageBuffer OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImage:(UIImage * _Nonnull)image OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionImage (SWIFT_EXTENSION(FritzVision))
- (CVPixelBufferRef _Nullable)rotate SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS_NAMED("FritzVisionImageMetadata")
@interface FritzVisionImageMetadata : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Orientation defaults to <code>FritzImageOrientation.right</code> which should work for rear facing cameras with a device orientation of Portrait.
@property (nonatomic) enum FritzImageOrientation orientation;
@property (nonatomic, readonly) CGImagePropertyOrientation cgOrientation;
@end


/// Represents a label for an image.
SWIFT_CLASS_NAMED("FritzVisionLabel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionLabel : NSObject
/// Human readable string of detected label.
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
/// Prediction confidence for label in range of [0, 1]
@property (nonatomic, readonly) double confidence;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithLabel:(NSString * _Nonnull)label confidence:(double)confidence OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, FritzVisionLabelError, closed) {
  FritzVisionLabelErrorNoVisionModel = 0,
};
static NSString * _Nonnull const FritzVisionLabelErrorDomain = @"FritzVision.FritzVisionLabelError";

@class FritzModelConfiguration;
@class FritzVisionLabelModelOptions;

SWIFT_CLASS_NAMED("FritzVisionLabelModel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionLabelModel : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
+ (void)setModelConfig:(FritzModelConfiguration * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
/// Run label prediction requst on a UIImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains an array of FritzVisionLabel objects or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionLabelModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<FritzVisionLabel *> * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLabelModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionLabelModel * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLabelModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionLabelModelOptions")
@interface FritzVisionLabelModelOptions : NSObject
/// Confidence threshold for prediction results in the range of [0, 1], default is 0.6.
@property (nonatomic) double threshold;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic, readonly) BOOL forceCoreMLPrediction;
/// Number of results to return from request.
@property (nonatomic) NSInteger numResults;
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class ModelSegmentationClass;

SWIFT_CLASS_NAMED("FritzVisionLivingRoomClass")
@interface FritzVisionLivingRoomClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull chair;)
+ (ModelSegmentationClass * _Nonnull)chair SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull wall;)
+ (ModelSegmentationClass * _Nonnull)wall SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull coffeeTable;)
+ (ModelSegmentationClass * _Nonnull)coffeeTable SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull ceiling;)
+ (ModelSegmentationClass * _Nonnull)ceiling SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull floor;)
+ (ModelSegmentationClass * _Nonnull)floor SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bed;)
+ (ModelSegmentationClass * _Nonnull)bed SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull lamp;)
+ (ModelSegmentationClass * _Nonnull)lamp SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sofa;)
+ (ModelSegmentationClass * _Nonnull)sofa SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull windowpane;)
+ (ModelSegmentationClass * _Nonnull)windowpane SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull pillow;)
+ (ModelSegmentationClass * _Nonnull)pillow SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzVisionSegmentationModelOptions;
@class FritzVisionSegmentationResult;

SWIFT_CLASS_NAMED("FritzVisionSegmentationModel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionSegmentationModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
@property (nonatomic, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull classes;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes;
/// Run image segmentation on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionSegmentationModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzVisionSegmentationResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Image segmentation model to detect common living room objects.
SWIFT_CLASS_NAMED("FritzVisionLivingRoomSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLivingRoomSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionLivingRoomSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionObject") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObject : NSObject
@property (nonatomic, readonly, strong) FritzVisionLabel * _Nonnull detectedLabel;
/// BoundingBox of detected object.
@property (nonatomic, readonly, strong) BoundingBox * _Nonnull boundingBox;
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
@property (nonatomic, readonly) double confidence;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithLabel:(FritzVisionLabel * _Nonnull)label boundingBox:(BoundingBox * _Nonnull)boundingBox OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("FritzVisionObjectModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionObjectModel * _Nullable, NSError * _Nullable))completionHandler;
@end

@class FritzVisionObjectModelOptions;

SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Run prediction for vision object model.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request has finished processing.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionObjectModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<FritzVisionObject *> * _Nullable, NSError * _Nullable))completion;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionObjectModelOptions")
@interface FritzVisionObjectModelOptions : NSObject
/// Confidence threshold for prediction results in the range of [0, 1], default is 0.6.
@property (nonatomic) double threshold;
/// Threshold for overlap of items within a single class in range [0, 1].  Lower values are more strict.
@property (nonatomic) float iouThreshold;
/// Number of results to return from request.
@property (nonatomic) NSInteger numResults;
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic, readonly) BOOL forceCoreMLPrediction;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionOutdoorClass")
@interface FritzVisionOutdoorClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull building;)
+ (ModelSegmentationClass * _Nonnull)building SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sky;)
+ (ModelSegmentationClass * _Nonnull)sky SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull tree;)
+ (ModelSegmentationClass * _Nonnull)tree SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sidewalk;)
+ (ModelSegmentationClass * _Nonnull)sidewalk SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull ground;)
+ (ModelSegmentationClass * _Nonnull)ground SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull car;)
+ (ModelSegmentationClass * _Nonnull)car SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull water;)
+ (ModelSegmentationClass * _Nonnull)water SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull house;)
+ (ModelSegmentationClass * _Nonnull)house SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull fence;)
+ (ModelSegmentationClass * _Nonnull)fence SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sign;)
+ (ModelSegmentationClass * _Nonnull)sign SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull skyscraper;)
+ (ModelSegmentationClass * _Nonnull)skyscraper SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bridge;)
+ (ModelSegmentationClass * _Nonnull)bridge SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull river;)
+ (ModelSegmentationClass * _Nonnull)river SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bus;)
+ (ModelSegmentationClass * _Nonnull)bus SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull truck;)
+ (ModelSegmentationClass * _Nonnull)truck SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull van;)
+ (ModelSegmentationClass * _Nonnull)van SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull motorbike;)
+ (ModelSegmentationClass * _Nonnull)motorbike SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bicycle;)
+ (ModelSegmentationClass * _Nonnull)bicycle SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull trafficLight;)
+ (ModelSegmentationClass * _Nonnull)trafficLight SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect common outdoor objects.
SWIFT_CLASS_NAMED("FritzVisionOutdoorSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionOutdoorSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionOutdoorSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Class labels for FritzVisionPeopleSegmentationModel
SWIFT_CLASS_NAMED("FritzVisionPeopleClass")
@interface FritzVisionPeopleClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationMediumClass")
@interface FritzVisionPeopleSegmentationMediumClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect people.
SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationMediumModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPeopleSegmentationMediumModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPeopleSegmentationMediumModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect people.
SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPeopleSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPeopleSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Model used to create a 3D pose from 2D pose
SWIFT_CLASS_NAMED("FritzVisionPoseLiftingModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseLiftingModel : BasePredictor
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzPose;
@class PoseLiftingPredictorOptions;
@class FritzPose3D;

SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseLiftingModel (SWIFT_EXTENSION(FritzVision))
/// Predict poses from an inputPose
/// \param input Input pose to process.
///
/// \param options The options used to configure the pose results.
///
/// \param completion Handler to call back on the main thread with poses or error.
///
- (void)predictWithImage:(FritzPose * _Nonnull)input options:(PoseLiftingPredictorOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzPose3D * _Nullable, NSError * _Nullable))completion;
@end

@class FritzVisionPoseModelOptions;
@class FritzVisionPoseResult;

/// A model used to predict the poses of people in images.
SWIFT_CLASS_NAMED("FritzVisionPoseModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseModel : BasePredictor
/// Model Configuration for pose model in Fritz.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
+ (void)setModelConfig:(FritzModelConfiguration * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
/// Is WiFi required to download pose model over the air.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Predict poses from a FritzImage.
/// \param input The image to use to dectect poses.
///
/// \param options The options used to configure the pose results.
///
/// \param completion Handler to call back on the main thread with poses or error.
///
- (void)predictWithImage:(FritzVisionImage * _Nonnull)input options:(FritzVisionPoseModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzVisionPoseResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPoseModel * _Nullable, NSError * _Nullable))completionHandler;
@end


/// Options for Pose Model.
SWIFT_CLASS_NAMED("FritzVisionPoseModelOptions")
@interface FritzVisionPoseModelOptions : NSObject
/// Crop and scale option. Default value is scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Minimum score a part must have to be included in a pose.
@property (nonatomic) double minPartThreshold;
/// Minimum score a pose must have to be included in results.
@property (nonatomic) double minPoseThreshold;
/// NMS radius for pose
@property (nonatomic) NSInteger nmsRadius;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@protocol MLFeatureProvider;

SWIFT_CLASS_NAMED("FritzVisionPoseResult") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseResult : NSObject
/// Model image width
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger modelInputWidth;)
+ (NSInteger)modelInputWidth SWIFT_WARN_UNUSED_RESULT;
/// Model image height
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger modelInputHeight;)
+ (NSInteger)modelInputHeight SWIFT_WARN_UNUSED_RESULT;
/// Original input image before it was rescaled
@property (nonatomic, readonly, strong) FritzVisionImage * _Nonnull image;
/// Pose model options.
@property (nonatomic, readonly, strong) FritzVisionPoseModelOptions * _Nonnull options;
/// Unavailable.  Use <code>FritzVisionPoseModel.predict</code> function to build.
- (nonnull instancetype)initForResults:(id <MLFeatureProvider> _Nonnull)results fritzImage:(FritzVisionImage * _Nonnull)fritzImage options:(FritzVisionPoseModelOptions * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseResult (SWIFT_EXTENSION(FritzVision))
/// Decode single pose result
///
/// returns:
/// Pose
- (FritzPose * _Nullable)decodePose SWIFT_WARN_UNUSED_RESULT;
/// Draw single pose on input image.
///
/// returns:
/// UIImage if pose detected.
- (UIImage * _Nullable)drawPose SWIFT_WARN_UNUSED_RESULT;
/// Draw detected poses on input image.
/// \param pose List of poses to draw
///
///
/// returns:
/// Original image with poses drawn on image.
- (UIImage * _Nullable)drawPose:(FritzPose * _Nonnull)pose SWIFT_WARN_UNUSED_RESULT;
@end



SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionSegmentationModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionSegmentationModelOptions")
@interface FritzVisionSegmentationModelOptions : NSObject
/// Crop and scale option. Default value is scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class MLMultiArray;

SWIFT_CLASS_NAMED("FritzVisionSegmentationResult") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionSegmentationResult : NSObject
/// Height of model output array.
@property (nonatomic, readonly) NSInteger height;
/// Width of model output array.
@property (nonatomic, readonly) NSInteger width;
/// Model classes.
@property (nonatomic, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull classes;
/// Raw MLMultiArray result from prediction.
@property (nonatomic, readonly, strong) MLMultiArray * _Nonnull predictionResult;
/// Create 2D-Array same size as the model output with each point representing most likely class.
/// \param minThreshold Only include classes that have a probability greater than the minThreshold.
///
- (NSArray<NSNumber *> * _Nonnull)getMaxIndices:(double)minThreshold SWIFT_WARN_UNUSED_RESULT;
/// Generate UIImage mask from most likely class at each pixel.
/// The generated image size will fit the original image passed into prediction, applying rotation.  If the image was center cropped, will return an image that covers the cropped image.
/// \param minThreshold Minimum threshold value needed to count. By default zero.  You can set this property to filter out classes that may be the most likely but still have a lower probability.
///
/// \param alpha Alpha value of the color (0-255) for detected classes. By default completely opaque.
///
- (UIImage * _Nullable)toImageMask:(double)minThreshold alpha:(uint8_t)alpha SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSNumber *> * _Nonnull)thresholdClass:(ModelSegmentationClass * _Nonnull)segmentClass threshold:(double)threshold minAccepted:(double)minAccepted SWIFT_WARN_UNUSED_RESULT;
/// Generate UIImage mask of given class, filtering out values below threshold.
/// The generated image size will fit the original image passed into prediction, applying rotation.  If the image was center cropped, will return an image that covers the cropped image.
/// \param segmentClass Class to mask.
///
/// \param threshold Probability to filter.  Any probabilities below this value will be filtered out.
///
/// \param alpha Alpha value of the color (0-255) for detected classes.
///
/// \param minThresholdAccepted Any confidence score below this value will have an alpha of 0. Class confidence scores between <code>minThresholdAccepted</code> and <code>threshold</code> will retain their original value.
///
- (UIImage * _Nullable)toImageMask:(ModelSegmentationClass * _Nonnull)segmentClass threshold:(double)threshold alpha:(uint8_t)alpha minThresholdAccepted:(double)minThresholdAccepted SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class FritzVisionStyleModelOptions;

SWIFT_CLASS_NAMED("FritzVisionStyleModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model error:(NSError * _Nullable * _Nullable)error;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
/// \param managedModel ManagedModel to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Run Style Transfer on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionStyleModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(CVPixelBufferRef _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel (SWIFT_EXTENSION(FritzVision))
/// Fetch and load Style Models for the given tags.
/// Note that this instantiates all models which could cause memory pressure if you are loading many models.
/// If you do not want to immediately instantiate the models, create a ModelTagManager and manage loading yourself.
/// \param tags List of tags to load models for.
///
/// \param wifiRequiredForModelDownload If true, client must be connected to a wifi network to download a model. Default is false.
///
/// \param completionHandler Completion handler with instantiated FritzVisionStyleModels
///
+ (void)fetchStyleModelsForTags:(NSArray<NSString *> * _Nonnull)tags wifiRequiredForModelDownload:(BOOL)wifiRequiredForModelDownload withCompletionHandler:(void (^ _Nonnull)(NSArray<FritzVisionStyleModel *> * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionStyleModelOptions")
@interface FritzVisionStyleModelOptions : NSObject
/// Crop and scale option.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Resize the output to match the FritzVisionImage size.
@property (nonatomic) BOOL resizeOutputToInputDimensions;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzPosePoint;
enum PosePart : NSInteger;

/// Predicted keypoint containing part, score, and position identified.
SWIFT_CLASS_NAMED("Keypoint")
@interface FritzPoseKeypoint : NSObject
@property (nonatomic, readonly) NSInteger id;
@property (nonatomic, readonly, strong) FritzPosePoint * _Nonnull position;
@property (nonatomic, readonly) double score;
@property (nonatomic, readonly) enum PosePart part;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class Point3D;

/// Predicted keypoint containing part, score, and position identified.
SWIFT_CLASS_NAMED("Keypoint3D")
@interface FritzPoseKeypoint3D : NSObject
@property (nonatomic, readonly) NSInteger id;
@property (nonatomic, readonly, strong) Point3D * _Nonnull position;
@property (nonatomic, readonly) double score;
@property (nonatomic, readonly) enum PosePart part;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("ModelSegmentationClass")
@interface ModelSegmentationClass : NSObject
/// Index in output array from model.
@property (nonatomic, readonly) NSInteger index;
/// Label name for Model Segmentation Class.
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Predicted point on model input coordinates.
SWIFT_CLASS_NAMED("Point")
@interface FritzPosePoint : NSObject
@property (nonatomic, readonly) double x;
@property (nonatomic, readonly) double y;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end
















SWIFT_CLASS("_TtC11FritzVision7Point3D")
@interface Point3D : NSObject
@property (nonatomic, readonly) double x;
@property (nonatomic, readonly) double y;
@property (nonatomic, readonly) double z;
- (nonnull instancetype)initWithX:(double)x y:(double)y z:(double)z OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (NSArray<NSNumber *> * _Nonnull)toArray SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface Point3D (SWIFT_EXTENSION(FritzVision))
- (nonnull instancetype)initWith:(NSArray<NSNumber *> * _Nonnull)array;
@end






/// Detected pose with Keypoints and corresponding score.
SWIFT_CLASS_NAMED("Pose") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzPose : NSObject
@property (nonatomic, readonly, copy) NSArray<FritzPoseKeypoint *> * _Nonnull keypoints;
@property (nonatomic, readonly) double score;
/// Create new Pose with keypoint positions scaled to be inside of rect.
/// \param rect Rect coordinates
///
///
/// returns:
/// New Pose with position inset in provided rect
- (FritzPose * _Nonnull)inRect:(CGRect)rect SWIFT_WARN_UNUSED_RESULT;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end






/// Detected pose with Keypoints and corresponding score.
SWIFT_CLASS_NAMED("Pose3D") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzPose3D : NSObject
@property (nonatomic, readonly, copy) NSArray<FritzPoseKeypoint3D *> * _Nonnull keypoints;
@property (nonatomic, readonly) double score;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end






/// Options for Pose Model.
SWIFT_CLASS("_TtC11FritzVision27PoseLiftingPredictorOptions")
@interface PoseLiftingPredictorOptions : NSObject
/// Default Pose model options.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) PoseLiftingPredictorOptions * _Nonnull defaults;)
+ (PoseLiftingPredictorOptions * _Nonnull)defaults SWIFT_WARN_UNUSED_RESULT;
/// If true only uses CPU to run predictions.
@property (nonatomic) BOOL useCPUOnly;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, PosePart, closed) {
  PosePartNose = 0,
  PosePartLeftEye = 1,
  PosePartRightEye = 2,
  PosePartLeftEar = 3,
  PosePartRightEar = 4,
  PosePartLeftShoulder = 5,
  PosePartRightShoulder = 6,
  PosePartLeftElbow = 7,
  PosePartRightElbow = 8,
  PosePartLeftWrist = 9,
  PosePartRightWrist = 10,
  PosePartLeftHip = 11,
  PosePartRightHip = 12,
  PosePartLeftKnee = 13,
  PosePartRightKnee = 14,
  PosePartLeftAnkle = 15,
  PosePartRightAnkle = 16,
};





#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#endif
#else
#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.0 (swiftlang-1001.0.69.5 clang-1001.0.46.3)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import CoreMedia;
@import CoreVideo;
@import ImageIO;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="FritzVision",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class FritzManagedModel;
@class FritzMLModel;

SWIFT_CLASS("_TtC11FritzVision13BasePredictor") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface BasePredictor : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize model with FritzMLModel
/// \param model FritzMLModel
///
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
/// Initialize model with FritzMLModel
/// \param model FritzMLModel
///
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// BoundingBox Contains coordinates to draw bounding boxes on images as predicted directly by the model.  However, because of cropping or resizing done to accomadate model size constraints, the default values may not map to coordinates in your view.  Use the toCGRect functions to convert bounding box coordinates to fit the image.
SWIFT_CLASS_NAMED("BoundingBox")
@interface BoundingBox : NSObject
- (nonnull instancetype)initWithYMin:(double)yMin xMin:(double)xMin yMax:(double)yMax xMax:(double)xMax OBJC_DESIGNATED_INITIALIZER;
- (CGRect)imgHeight:(double)imgHeight imgWidth:(double)imgWidth SWIFT_WARN_UNUSED_RESULT;
- (CGRect)imgHeight:(double)imgHeight imgWidth:(double)imgWidth xOffset:(double)xOffset yOffset:(double)yOffset SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CALayer;
@class UIColor;

SWIFT_CLASS_NAMED("BoundingBoxOutline")
@interface BoundingBoxOutline : NSObject
/// Add shape and text to parent layer
/// \param parent parent CALayer
///
- (void)parent:(CALayer * _Nonnull)parent;
/// Show Bounding box.
/// \param frame CGRect of coordinates to draw box
///
/// \param label Classified label
///
/// \param color Color of bounding box outline
///
/// \param textColor Classified label text
///
- (void)frame:(CGRect)frame label:(NSString * _Nonnull)label color:(UIColor * _Nonnull)color textColor:(UIColor * _Nonnull)textColor;
/// Hide bounding box from appearing in view.
- (void)hide;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("FlexibleModelDimensions")
@interface FlexibleModelDimensions : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithSize:(CGSize)size OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithWidth:(NSInteger)width withHeight:(NSInteger)height OBJC_DESIGNATED_INITIALIZER;
@end


@interface FlexibleModelDimensions (SWIFT_EXTENSION(FritzVision))
/// Use original image dimensions.  Model will throw an error if image dimensions are not within range of acceptable input sizes.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull original;)
+ (FlexibleModelDimensions * _Nonnull)original SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull lowResolution;)
+ (FlexibleModelDimensions * _Nonnull)lowResolution SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull mediumResolution;)
+ (FlexibleModelDimensions * _Nonnull)mediumResolution SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull highResolution;)
+ (FlexibleModelDimensions * _Nonnull)highResolution SWIFT_WARN_UNUSED_RESULT;
@end

/// Describes the orientation of the image. The orientations match the <a href="https://developer.apple.com/documentation/imageio/cgimagepropertyorientation">CGImagePropertyOrientation</a> Enumeration from Apple. Refer to that documentation for clear descriptions of each case.
typedef SWIFT_ENUM(int32_t, FritzImageOrientation, closed) {
  FritzImageOrientationUp = 1,
  FritzImageOrientationUpMirrored = 2,
  FritzImageOrientationDown = 3,
  FritzImageOrientationDownMirrored = 4,
  FritzImageOrientationLeftMirrored = 5,
  FritzImageOrientationRight = 6,
  FritzImageOrientationRightMirrored = 7,
  FritzImageOrientationLeft = 8,
};

typedef SWIFT_ENUM_NAMED(NSInteger, FritzVisionCropAndScale, "FritzVisionCropAndScale", closed) {
  FritzVisionCropAndScaleCenterCrop = 1,
  FritzVisionCropAndScaleScaleFill = 2,
  FritzVisionCropAndScaleScaleFit = 3,
};

typedef SWIFT_ENUM(NSInteger, FritzVisionError, closed) {
  FritzVisionErrorInvalidSampleImageBuffer = 0,
  FritzVisionErrorErrorProcessingImage = 1,
};
static NSString * _Nonnull const FritzVisionErrorDomain = @"FritzVision.FritzVisionError";

@protocol FritzSwiftIdentifiedModel;
@class FritzVisionImage;
@class FritzVisionFlexibleStyleModelOptions;

/// Construct a Flexible Style Transfer model and run on any FritzVisionImage. Use this class over <code>FritzVisionStyleTransferModel</code> to produce stylized images with customizable output sizes.
SWIFT_CLASS_NAMED("FritzVisionFlexibleStyleModel") SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model;
/// Initialize FritzVisionFlexibleStyleModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Initialize FritzVisionFlexibleStyleModel with your own trained style model.
/// \param model Fritz model to use.
///
/// \param managedModel FritzManagedModel to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Run Style Transfer on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionFlexibleStyleModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(CVPixelBufferRef _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel (SWIFT_EXTENSION(FritzVision))
/// Fetch and load Style Models for the given tags.
/// Note that this instantiates all models which could cause memory pressure if you are loading many models.
/// If you do not want to immediately instantiate the models, create a ModelTagManager and manage loading yourself.
/// \param tags List of tags to load models for.
///
/// \param wifiRequiredForModelDownload If true, client must be connected to a wifi network to download a model. Default is false.
///
/// \param completionHandler Completion handler with instantiated FritzVisionStyleModels
///
+ (void)fetchStyleModelsForTags:(NSArray<NSString *> * _Nonnull)tags wifiRequiredForModelDownload:(BOOL)wifiRequiredForModelDownload withCompletionHandler:(void (^ _Nonnull)(NSArray<FritzVisionFlexibleStyleModel *> * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


/// Options for how to run flexible style transfer model.
SWIFT_CLASS_NAMED("FritzVisionFlexibleStyleModelOptions")
@interface FritzVisionFlexibleStyleModelOptions : NSObject
/// Crop and scale option. Default option is .scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Set dimensions for output result of flexible model.
@property (nonatomic, strong) FlexibleModelDimensions * _Nonnull flexibleModelDimensions;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class UIImage;

/// An image or image buffer used in vision detection.
SWIFT_CLASS_NAMED("FritzVisionImage") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionImage : NSObject
- (nonnull instancetype)initWithBuffer:(CMSampleBufferRef _Nonnull)buffer OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImageBuffer:(CVPixelBufferRef _Nonnull)imageBuffer OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImage:(UIImage * _Nonnull)image OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionImage (SWIFT_EXTENSION(FritzVision))
- (CVPixelBufferRef _Nullable)rotate SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS_NAMED("FritzVisionImageMetadata")
@interface FritzVisionImageMetadata : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Orientation defaults to <code>FritzImageOrientation.right</code> which should work for rear facing cameras with a device orientation of Portrait.
@property (nonatomic) enum FritzImageOrientation orientation;
@property (nonatomic, readonly) CGImagePropertyOrientation cgOrientation;
@end


/// Represents a label for an image.
SWIFT_CLASS_NAMED("FritzVisionLabel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionLabel : NSObject
/// Human readable string of detected label.
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
/// Prediction confidence for label in range of [0, 1]
@property (nonatomic, readonly) double confidence;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithLabel:(NSString * _Nonnull)label confidence:(double)confidence OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, FritzVisionLabelError, closed) {
  FritzVisionLabelErrorNoVisionModel = 0,
};
static NSString * _Nonnull const FritzVisionLabelErrorDomain = @"FritzVision.FritzVisionLabelError";

@class FritzModelConfiguration;
@class FritzVisionLabelModelOptions;

SWIFT_CLASS_NAMED("FritzVisionLabelModel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionLabelModel : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
+ (void)setModelConfig:(FritzModelConfiguration * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
/// Run label prediction requst on a UIImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains an array of FritzVisionLabel objects or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionLabelModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<FritzVisionLabel *> * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLabelModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionLabelModel * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLabelModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionLabelModelOptions")
@interface FritzVisionLabelModelOptions : NSObject
/// Confidence threshold for prediction results in the range of [0, 1], default is 0.6.
@property (nonatomic) double threshold;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic, readonly) BOOL forceCoreMLPrediction;
/// Number of results to return from request.
@property (nonatomic) NSInteger numResults;
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class ModelSegmentationClass;

SWIFT_CLASS_NAMED("FritzVisionLivingRoomClass")
@interface FritzVisionLivingRoomClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull chair;)
+ (ModelSegmentationClass * _Nonnull)chair SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull wall;)
+ (ModelSegmentationClass * _Nonnull)wall SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull coffeeTable;)
+ (ModelSegmentationClass * _Nonnull)coffeeTable SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull ceiling;)
+ (ModelSegmentationClass * _Nonnull)ceiling SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull floor;)
+ (ModelSegmentationClass * _Nonnull)floor SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bed;)
+ (ModelSegmentationClass * _Nonnull)bed SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull lamp;)
+ (ModelSegmentationClass * _Nonnull)lamp SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sofa;)
+ (ModelSegmentationClass * _Nonnull)sofa SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull windowpane;)
+ (ModelSegmentationClass * _Nonnull)windowpane SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull pillow;)
+ (ModelSegmentationClass * _Nonnull)pillow SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzVisionSegmentationModelOptions;
@class FritzVisionSegmentationResult;

SWIFT_CLASS_NAMED("FritzVisionSegmentationModel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionSegmentationModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
@property (nonatomic, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull classes;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes;
/// Run image segmentation on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionSegmentationModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzVisionSegmentationResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Image segmentation model to detect common living room objects.
SWIFT_CLASS_NAMED("FritzVisionLivingRoomSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLivingRoomSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionLivingRoomSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionObject") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObject : NSObject
@property (nonatomic, readonly, strong) FritzVisionLabel * _Nonnull detectedLabel;
/// BoundingBox of detected object.
@property (nonatomic, readonly, strong) BoundingBox * _Nonnull boundingBox;
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
@property (nonatomic, readonly) double confidence;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithLabel:(FritzVisionLabel * _Nonnull)label boundingBox:(BoundingBox * _Nonnull)boundingBox OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("FritzVisionObjectModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionObjectModel * _Nullable, NSError * _Nullable))completionHandler;
@end

@class FritzVisionObjectModelOptions;

SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Run prediction for vision object model.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request has finished processing.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionObjectModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<FritzVisionObject *> * _Nullable, NSError * _Nullable))completion;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionObjectModelOptions")
@interface FritzVisionObjectModelOptions : NSObject
/// Confidence threshold for prediction results in the range of [0, 1], default is 0.6.
@property (nonatomic) double threshold;
/// Threshold for overlap of items within a single class in range [0, 1].  Lower values are more strict.
@property (nonatomic) float iouThreshold;
/// Number of results to return from request.
@property (nonatomic) NSInteger numResults;
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic, readonly) BOOL forceCoreMLPrediction;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionOutdoorClass")
@interface FritzVisionOutdoorClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull building;)
+ (ModelSegmentationClass * _Nonnull)building SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sky;)
+ (ModelSegmentationClass * _Nonnull)sky SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull tree;)
+ (ModelSegmentationClass * _Nonnull)tree SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sidewalk;)
+ (ModelSegmentationClass * _Nonnull)sidewalk SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull ground;)
+ (ModelSegmentationClass * _Nonnull)ground SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull car;)
+ (ModelSegmentationClass * _Nonnull)car SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull water;)
+ (ModelSegmentationClass * _Nonnull)water SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull house;)
+ (ModelSegmentationClass * _Nonnull)house SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull fence;)
+ (ModelSegmentationClass * _Nonnull)fence SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sign;)
+ (ModelSegmentationClass * _Nonnull)sign SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull skyscraper;)
+ (ModelSegmentationClass * _Nonnull)skyscraper SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bridge;)
+ (ModelSegmentationClass * _Nonnull)bridge SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull river;)
+ (ModelSegmentationClass * _Nonnull)river SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bus;)
+ (ModelSegmentationClass * _Nonnull)bus SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull truck;)
+ (ModelSegmentationClass * _Nonnull)truck SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull van;)
+ (ModelSegmentationClass * _Nonnull)van SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull motorbike;)
+ (ModelSegmentationClass * _Nonnull)motorbike SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bicycle;)
+ (ModelSegmentationClass * _Nonnull)bicycle SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull trafficLight;)
+ (ModelSegmentationClass * _Nonnull)trafficLight SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect common outdoor objects.
SWIFT_CLASS_NAMED("FritzVisionOutdoorSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionOutdoorSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionOutdoorSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Class labels for FritzVisionPeopleSegmentationModel
SWIFT_CLASS_NAMED("FritzVisionPeopleClass")
@interface FritzVisionPeopleClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationMediumClass")
@interface FritzVisionPeopleSegmentationMediumClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect people.
SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationMediumModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPeopleSegmentationMediumModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPeopleSegmentationMediumModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect people.
SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPeopleSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPeopleSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Model used to create a 3D pose from 2D pose
SWIFT_CLASS_NAMED("FritzVisionPoseLiftingModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseLiftingModel : BasePredictor
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzPose;
@class PoseLiftingPredictorOptions;
@class FritzPose3D;

SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseLiftingModel (SWIFT_EXTENSION(FritzVision))
/// Predict poses from an inputPose
/// \param input Input pose to process.
///
/// \param options The options used to configure the pose results.
///
/// \param completion Handler to call back on the main thread with poses or error.
///
- (void)predictWithImage:(FritzPose * _Nonnull)input options:(PoseLiftingPredictorOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzPose3D * _Nullable, NSError * _Nullable))completion;
@end

@class FritzVisionPoseModelOptions;
@class FritzVisionPoseResult;

/// A model used to predict the poses of people in images.
SWIFT_CLASS_NAMED("FritzVisionPoseModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseModel : BasePredictor
/// Model Configuration for pose model in Fritz.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
+ (void)setModelConfig:(FritzModelConfiguration * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
/// Is WiFi required to download pose model over the air.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Predict poses from a FritzImage.
/// \param input The image to use to dectect poses.
///
/// \param options The options used to configure the pose results.
///
/// \param completion Handler to call back on the main thread with poses or error.
///
- (void)predictWithImage:(FritzVisionImage * _Nonnull)input options:(FritzVisionPoseModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzVisionPoseResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPoseModel * _Nullable, NSError * _Nullable))completionHandler;
@end


/// Options for Pose Model.
SWIFT_CLASS_NAMED("FritzVisionPoseModelOptions")
@interface FritzVisionPoseModelOptions : NSObject
/// Crop and scale option. Default value is scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Minimum score a part must have to be included in a pose.
@property (nonatomic) double minPartThreshold;
/// Minimum score a pose must have to be included in results.
@property (nonatomic) double minPoseThreshold;
/// NMS radius for pose
@property (nonatomic) NSInteger nmsRadius;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@protocol MLFeatureProvider;

SWIFT_CLASS_NAMED("FritzVisionPoseResult") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseResult : NSObject
/// Model image width
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger modelInputWidth;)
+ (NSInteger)modelInputWidth SWIFT_WARN_UNUSED_RESULT;
/// Model image height
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger modelInputHeight;)
+ (NSInteger)modelInputHeight SWIFT_WARN_UNUSED_RESULT;
/// Original input image before it was rescaled
@property (nonatomic, readonly, strong) FritzVisionImage * _Nonnull image;
/// Pose model options.
@property (nonatomic, readonly, strong) FritzVisionPoseModelOptions * _Nonnull options;
/// Unavailable.  Use <code>FritzVisionPoseModel.predict</code> function to build.
- (nonnull instancetype)initForResults:(id <MLFeatureProvider> _Nonnull)results fritzImage:(FritzVisionImage * _Nonnull)fritzImage options:(FritzVisionPoseModelOptions * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseResult (SWIFT_EXTENSION(FritzVision))
/// Decode single pose result
///
/// returns:
/// Pose
- (FritzPose * _Nullable)decodePose SWIFT_WARN_UNUSED_RESULT;
/// Draw single pose on input image.
///
/// returns:
/// UIImage if pose detected.
- (UIImage * _Nullable)drawPose SWIFT_WARN_UNUSED_RESULT;
/// Draw detected poses on input image.
/// \param pose List of poses to draw
///
///
/// returns:
/// Original image with poses drawn on image.
- (UIImage * _Nullable)drawPose:(FritzPose * _Nonnull)pose SWIFT_WARN_UNUSED_RESULT;
@end



SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionSegmentationModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionSegmentationModelOptions")
@interface FritzVisionSegmentationModelOptions : NSObject
/// Crop and scale option. Default value is scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class MLMultiArray;

SWIFT_CLASS_NAMED("FritzVisionSegmentationResult") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionSegmentationResult : NSObject
/// Height of model output array.
@property (nonatomic, readonly) NSInteger height;
/// Width of model output array.
@property (nonatomic, readonly) NSInteger width;
/// Model classes.
@property (nonatomic, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull classes;
/// Raw MLMultiArray result from prediction.
@property (nonatomic, readonly, strong) MLMultiArray * _Nonnull predictionResult;
/// Create 2D-Array same size as the model output with each point representing most likely class.
/// \param minThreshold Only include classes that have a probability greater than the minThreshold.
///
- (NSArray<NSNumber *> * _Nonnull)getMaxIndices:(double)minThreshold SWIFT_WARN_UNUSED_RESULT;
/// Generate UIImage mask from most likely class at each pixel.
/// The generated image size will fit the original image passed into prediction, applying rotation.  If the image was center cropped, will return an image that covers the cropped image.
/// \param minThreshold Minimum threshold value needed to count. By default zero.  You can set this property to filter out classes that may be the most likely but still have a lower probability.
///
/// \param alpha Alpha value of the color (0-255) for detected classes. By default completely opaque.
///
- (UIImage * _Nullable)toImageMask:(double)minThreshold alpha:(uint8_t)alpha SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSNumber *> * _Nonnull)thresholdClass:(ModelSegmentationClass * _Nonnull)segmentClass threshold:(double)threshold minAccepted:(double)minAccepted SWIFT_WARN_UNUSED_RESULT;
/// Generate UIImage mask of given class, filtering out values below threshold.
/// The generated image size will fit the original image passed into prediction, applying rotation.  If the image was center cropped, will return an image that covers the cropped image.
/// \param segmentClass Class to mask.
///
/// \param threshold Probability to filter.  Any probabilities below this value will be filtered out.
///
/// \param alpha Alpha value of the color (0-255) for detected classes.
///
/// \param minThresholdAccepted Any confidence score below this value will have an alpha of 0. Class confidence scores between <code>minThresholdAccepted</code> and <code>threshold</code> will retain their original value.
///
- (UIImage * _Nullable)toImageMask:(ModelSegmentationClass * _Nonnull)segmentClass threshold:(double)threshold alpha:(uint8_t)alpha minThresholdAccepted:(double)minThresholdAccepted SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class FritzVisionStyleModelOptions;

SWIFT_CLASS_NAMED("FritzVisionStyleModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model error:(NSError * _Nullable * _Nullable)error;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
/// \param managedModel ManagedModel to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Run Style Transfer on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionStyleModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(CVPixelBufferRef _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel (SWIFT_EXTENSION(FritzVision))
/// Fetch and load Style Models for the given tags.
/// Note that this instantiates all models which could cause memory pressure if you are loading many models.
/// If you do not want to immediately instantiate the models, create a ModelTagManager and manage loading yourself.
/// \param tags List of tags to load models for.
///
/// \param wifiRequiredForModelDownload If true, client must be connected to a wifi network to download a model. Default is false.
///
/// \param completionHandler Completion handler with instantiated FritzVisionStyleModels
///
+ (void)fetchStyleModelsForTags:(NSArray<NSString *> * _Nonnull)tags wifiRequiredForModelDownload:(BOOL)wifiRequiredForModelDownload withCompletionHandler:(void (^ _Nonnull)(NSArray<FritzVisionStyleModel *> * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionStyleModelOptions")
@interface FritzVisionStyleModelOptions : NSObject
/// Crop and scale option.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Resize the output to match the FritzVisionImage size.
@property (nonatomic) BOOL resizeOutputToInputDimensions;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzPosePoint;
enum PosePart : NSInteger;

/// Predicted keypoint containing part, score, and position identified.
SWIFT_CLASS_NAMED("Keypoint")
@interface FritzPoseKeypoint : NSObject
@property (nonatomic, readonly) NSInteger id;
@property (nonatomic, readonly, strong) FritzPosePoint * _Nonnull position;
@property (nonatomic, readonly) double score;
@property (nonatomic, readonly) enum PosePart part;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class Point3D;

/// Predicted keypoint containing part, score, and position identified.
SWIFT_CLASS_NAMED("Keypoint3D")
@interface FritzPoseKeypoint3D : NSObject
@property (nonatomic, readonly) NSInteger id;
@property (nonatomic, readonly, strong) Point3D * _Nonnull position;
@property (nonatomic, readonly) double score;
@property (nonatomic, readonly) enum PosePart part;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("ModelSegmentationClass")
@interface ModelSegmentationClass : NSObject
/// Index in output array from model.
@property (nonatomic, readonly) NSInteger index;
/// Label name for Model Segmentation Class.
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Predicted point on model input coordinates.
SWIFT_CLASS_NAMED("Point")
@interface FritzPosePoint : NSObject
@property (nonatomic, readonly) double x;
@property (nonatomic, readonly) double y;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end
















SWIFT_CLASS("_TtC11FritzVision7Point3D")
@interface Point3D : NSObject
@property (nonatomic, readonly) double x;
@property (nonatomic, readonly) double y;
@property (nonatomic, readonly) double z;
- (nonnull instancetype)initWithX:(double)x y:(double)y z:(double)z OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (NSArray<NSNumber *> * _Nonnull)toArray SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface Point3D (SWIFT_EXTENSION(FritzVision))
- (nonnull instancetype)initWith:(NSArray<NSNumber *> * _Nonnull)array;
@end






/// Detected pose with Keypoints and corresponding score.
SWIFT_CLASS_NAMED("Pose") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzPose : NSObject
@property (nonatomic, readonly, copy) NSArray<FritzPoseKeypoint *> * _Nonnull keypoints;
@property (nonatomic, readonly) double score;
/// Create new Pose with keypoint positions scaled to be inside of rect.
/// \param rect Rect coordinates
///
///
/// returns:
/// New Pose with position inset in provided rect
- (FritzPose * _Nonnull)inRect:(CGRect)rect SWIFT_WARN_UNUSED_RESULT;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end






/// Detected pose with Keypoints and corresponding score.
SWIFT_CLASS_NAMED("Pose3D") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzPose3D : NSObject
@property (nonatomic, readonly, copy) NSArray<FritzPoseKeypoint3D *> * _Nonnull keypoints;
@property (nonatomic, readonly) double score;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end






/// Options for Pose Model.
SWIFT_CLASS("_TtC11FritzVision27PoseLiftingPredictorOptions")
@interface PoseLiftingPredictorOptions : NSObject
/// Default Pose model options.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) PoseLiftingPredictorOptions * _Nonnull defaults;)
+ (PoseLiftingPredictorOptions * _Nonnull)defaults SWIFT_WARN_UNUSED_RESULT;
/// If true only uses CPU to run predictions.
@property (nonatomic) BOOL useCPUOnly;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, PosePart, closed) {
  PosePartNose = 0,
  PosePartLeftEye = 1,
  PosePartRightEye = 2,
  PosePartLeftEar = 3,
  PosePartRightEar = 4,
  PosePartLeftShoulder = 5,
  PosePartRightShoulder = 6,
  PosePartLeftElbow = 7,
  PosePartRightElbow = 8,
  PosePartLeftWrist = 9,
  PosePartRightWrist = 10,
  PosePartLeftHip = 11,
  PosePartRightHip = 12,
  PosePartLeftKnee = 13,
  PosePartRightKnee = 14,
  PosePartLeftAnkle = 15,
  PosePartRightAnkle = 16,
};





#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__ARM_ARCH_7A__) && __ARM_ARCH_7A__
// Generated by Apple Swift version 5.0 (swiftlang-1001.0.69.5 clang-1001.0.46.3)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import CoreMedia;
@import CoreVideo;
@import ImageIO;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="FritzVision",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class FritzManagedModel;
@class FritzMLModel;

SWIFT_CLASS("_TtC11FritzVision13BasePredictor") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface BasePredictor : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize model with FritzMLModel
/// \param model FritzMLModel
///
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
/// Initialize model with FritzMLModel
/// \param model FritzMLModel
///
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// BoundingBox Contains coordinates to draw bounding boxes on images as predicted directly by the model.  However, because of cropping or resizing done to accomadate model size constraints, the default values may not map to coordinates in your view.  Use the toCGRect functions to convert bounding box coordinates to fit the image.
SWIFT_CLASS_NAMED("BoundingBox")
@interface BoundingBox : NSObject
- (nonnull instancetype)initWithYMin:(double)yMin xMin:(double)xMin yMax:(double)yMax xMax:(double)xMax OBJC_DESIGNATED_INITIALIZER;
- (CGRect)imgHeight:(double)imgHeight imgWidth:(double)imgWidth SWIFT_WARN_UNUSED_RESULT;
- (CGRect)imgHeight:(double)imgHeight imgWidth:(double)imgWidth xOffset:(double)xOffset yOffset:(double)yOffset SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CALayer;
@class UIColor;

SWIFT_CLASS_NAMED("BoundingBoxOutline")
@interface BoundingBoxOutline : NSObject
/// Add shape and text to parent layer
/// \param parent parent CALayer
///
- (void)parent:(CALayer * _Nonnull)parent;
/// Show Bounding box.
/// \param frame CGRect of coordinates to draw box
///
/// \param label Classified label
///
/// \param color Color of bounding box outline
///
/// \param textColor Classified label text
///
- (void)frame:(CGRect)frame label:(NSString * _Nonnull)label color:(UIColor * _Nonnull)color textColor:(UIColor * _Nonnull)textColor;
/// Hide bounding box from appearing in view.
- (void)hide;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("FlexibleModelDimensions")
@interface FlexibleModelDimensions : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithSize:(CGSize)size OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithWidth:(NSInteger)width withHeight:(NSInteger)height OBJC_DESIGNATED_INITIALIZER;
@end


@interface FlexibleModelDimensions (SWIFT_EXTENSION(FritzVision))
/// Use original image dimensions.  Model will throw an error if image dimensions are not within range of acceptable input sizes.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull original;)
+ (FlexibleModelDimensions * _Nonnull)original SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull lowResolution;)
+ (FlexibleModelDimensions * _Nonnull)lowResolution SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull mediumResolution;)
+ (FlexibleModelDimensions * _Nonnull)mediumResolution SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FlexibleModelDimensions * _Nonnull highResolution;)
+ (FlexibleModelDimensions * _Nonnull)highResolution SWIFT_WARN_UNUSED_RESULT;
@end

/// Describes the orientation of the image. The orientations match the <a href="https://developer.apple.com/documentation/imageio/cgimagepropertyorientation">CGImagePropertyOrientation</a> Enumeration from Apple. Refer to that documentation for clear descriptions of each case.
typedef SWIFT_ENUM(int32_t, FritzImageOrientation, closed) {
  FritzImageOrientationUp = 1,
  FritzImageOrientationUpMirrored = 2,
  FritzImageOrientationDown = 3,
  FritzImageOrientationDownMirrored = 4,
  FritzImageOrientationLeftMirrored = 5,
  FritzImageOrientationRight = 6,
  FritzImageOrientationRightMirrored = 7,
  FritzImageOrientationLeft = 8,
};

typedef SWIFT_ENUM_NAMED(NSInteger, FritzVisionCropAndScale, "FritzVisionCropAndScale", closed) {
  FritzVisionCropAndScaleCenterCrop = 1,
  FritzVisionCropAndScaleScaleFill = 2,
  FritzVisionCropAndScaleScaleFit = 3,
};

typedef SWIFT_ENUM(NSInteger, FritzVisionError, closed) {
  FritzVisionErrorInvalidSampleImageBuffer = 0,
  FritzVisionErrorErrorProcessingImage = 1,
};
static NSString * _Nonnull const FritzVisionErrorDomain = @"FritzVision.FritzVisionError";

@protocol FritzSwiftIdentifiedModel;
@class FritzVisionImage;
@class FritzVisionFlexibleStyleModelOptions;

/// Construct a Flexible Style Transfer model and run on any FritzVisionImage. Use this class over <code>FritzVisionStyleTransferModel</code> to produce stylized images with customizable output sizes.
SWIFT_CLASS_NAMED("FritzVisionFlexibleStyleModel") SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model;
/// Initialize FritzVisionFlexibleStyleModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Initialize FritzVisionFlexibleStyleModel with your own trained style model.
/// \param model Fritz model to use.
///
/// \param managedModel FritzManagedModel to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Run Style Transfer on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionFlexibleStyleModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(CVPixelBufferRef _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel (SWIFT_EXTENSION(FritzVision))
/// Fetch and load Style Models for the given tags.
/// Note that this instantiates all models which could cause memory pressure if you are loading many models.
/// If you do not want to immediately instantiate the models, create a ModelTagManager and manage loading yourself.
/// \param tags List of tags to load models for.
///
/// \param wifiRequiredForModelDownload If true, client must be connected to a wifi network to download a model. Default is false.
///
/// \param completionHandler Completion handler with instantiated FritzVisionStyleModels
///
+ (void)fetchStyleModelsForTags:(NSArray<NSString *> * _Nonnull)tags wifiRequiredForModelDownload:(BOOL)wifiRequiredForModelDownload withCompletionHandler:(void (^ _Nonnull)(NSArray<FritzVisionFlexibleStyleModel *> * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=12.0)
@interface FritzVisionFlexibleStyleModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


/// Options for how to run flexible style transfer model.
SWIFT_CLASS_NAMED("FritzVisionFlexibleStyleModelOptions")
@interface FritzVisionFlexibleStyleModelOptions : NSObject
/// Crop and scale option. Default option is .scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Set dimensions for output result of flexible model.
@property (nonatomic, strong) FlexibleModelDimensions * _Nonnull flexibleModelDimensions;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class UIImage;

/// An image or image buffer used in vision detection.
SWIFT_CLASS_NAMED("FritzVisionImage") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionImage : NSObject
- (nonnull instancetype)initWithBuffer:(CMSampleBufferRef _Nonnull)buffer OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImageBuffer:(CVPixelBufferRef _Nonnull)imageBuffer OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImage:(UIImage * _Nonnull)image OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionImage (SWIFT_EXTENSION(FritzVision))
- (CVPixelBufferRef _Nullable)rotate SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS_NAMED("FritzVisionImageMetadata")
@interface FritzVisionImageMetadata : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Orientation defaults to <code>FritzImageOrientation.right</code> which should work for rear facing cameras with a device orientation of Portrait.
@property (nonatomic) enum FritzImageOrientation orientation;
@property (nonatomic, readonly) CGImagePropertyOrientation cgOrientation;
@end


/// Represents a label for an image.
SWIFT_CLASS_NAMED("FritzVisionLabel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionLabel : NSObject
/// Human readable string of detected label.
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
/// Prediction confidence for label in range of [0, 1]
@property (nonatomic, readonly) double confidence;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithLabel:(NSString * _Nonnull)label confidence:(double)confidence OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, FritzVisionLabelError, closed) {
  FritzVisionLabelErrorNoVisionModel = 0,
};
static NSString * _Nonnull const FritzVisionLabelErrorDomain = @"FritzVision.FritzVisionLabelError";

@class FritzModelConfiguration;
@class FritzVisionLabelModelOptions;

SWIFT_CLASS_NAMED("FritzVisionLabelModel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionLabelModel : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
+ (void)setModelConfig:(FritzModelConfiguration * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
/// Run label prediction requst on a UIImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains an array of FritzVisionLabel objects or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionLabelModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<FritzVisionLabel *> * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLabelModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionLabelModel * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLabelModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionLabelModelOptions")
@interface FritzVisionLabelModelOptions : NSObject
/// Confidence threshold for prediction results in the range of [0, 1], default is 0.6.
@property (nonatomic) double threshold;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic, readonly) BOOL forceCoreMLPrediction;
/// Number of results to return from request.
@property (nonatomic) NSInteger numResults;
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class ModelSegmentationClass;

SWIFT_CLASS_NAMED("FritzVisionLivingRoomClass")
@interface FritzVisionLivingRoomClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull chair;)
+ (ModelSegmentationClass * _Nonnull)chair SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull wall;)
+ (ModelSegmentationClass * _Nonnull)wall SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull coffeeTable;)
+ (ModelSegmentationClass * _Nonnull)coffeeTable SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull ceiling;)
+ (ModelSegmentationClass * _Nonnull)ceiling SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull floor;)
+ (ModelSegmentationClass * _Nonnull)floor SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bed;)
+ (ModelSegmentationClass * _Nonnull)bed SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull lamp;)
+ (ModelSegmentationClass * _Nonnull)lamp SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sofa;)
+ (ModelSegmentationClass * _Nonnull)sofa SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull windowpane;)
+ (ModelSegmentationClass * _Nonnull)windowpane SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull pillow;)
+ (ModelSegmentationClass * _Nonnull)pillow SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzVisionSegmentationModelOptions;
@class FritzVisionSegmentationResult;

SWIFT_CLASS_NAMED("FritzVisionSegmentationModel") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionSegmentationModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
@property (nonatomic, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull classes;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes;
/// Run image segmentation on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionSegmentationModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzVisionSegmentationResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Image segmentation model to detect common living room objects.
SWIFT_CLASS_NAMED("FritzVisionLivingRoomSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionLivingRoomSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionLivingRoomSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionObject") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObject : NSObject
@property (nonatomic, readonly, strong) FritzVisionLabel * _Nonnull detectedLabel;
/// BoundingBox of detected object.
@property (nonatomic, readonly, strong) BoundingBox * _Nonnull boundingBox;
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
@property (nonatomic, readonly) double confidence;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithLabel:(FritzVisionLabel * _Nonnull)label boundingBox:(BoundingBox * _Nonnull)boundingBox OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("FritzVisionObjectModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionObjectModel * _Nullable, NSError * _Nullable))completionHandler;
@end

@class FritzVisionObjectModelOptions;

SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Run prediction for vision object model.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request has finished processing.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionObjectModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<FritzVisionObject *> * _Nullable, NSError * _Nullable))completion;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionObjectModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionObjectModelOptions")
@interface FritzVisionObjectModelOptions : NSObject
/// Confidence threshold for prediction results in the range of [0, 1], default is 0.6.
@property (nonatomic) double threshold;
/// Threshold for overlap of items within a single class in range [0, 1].  Lower values are more strict.
@property (nonatomic) float iouThreshold;
/// Number of results to return from request.
@property (nonatomic) NSInteger numResults;
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic, readonly) BOOL forceCoreMLPrediction;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionOutdoorClass")
@interface FritzVisionOutdoorClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull building;)
+ (ModelSegmentationClass * _Nonnull)building SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sky;)
+ (ModelSegmentationClass * _Nonnull)sky SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull tree;)
+ (ModelSegmentationClass * _Nonnull)tree SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sidewalk;)
+ (ModelSegmentationClass * _Nonnull)sidewalk SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull ground;)
+ (ModelSegmentationClass * _Nonnull)ground SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull car;)
+ (ModelSegmentationClass * _Nonnull)car SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull water;)
+ (ModelSegmentationClass * _Nonnull)water SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull house;)
+ (ModelSegmentationClass * _Nonnull)house SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull fence;)
+ (ModelSegmentationClass * _Nonnull)fence SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull sign;)
+ (ModelSegmentationClass * _Nonnull)sign SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull skyscraper;)
+ (ModelSegmentationClass * _Nonnull)skyscraper SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bridge;)
+ (ModelSegmentationClass * _Nonnull)bridge SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull river;)
+ (ModelSegmentationClass * _Nonnull)river SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bus;)
+ (ModelSegmentationClass * _Nonnull)bus SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull truck;)
+ (ModelSegmentationClass * _Nonnull)truck SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull van;)
+ (ModelSegmentationClass * _Nonnull)van SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull motorbike;)
+ (ModelSegmentationClass * _Nonnull)motorbike SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull bicycle;)
+ (ModelSegmentationClass * _Nonnull)bicycle SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull trafficLight;)
+ (ModelSegmentationClass * _Nonnull)trafficLight SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect common outdoor objects.
SWIFT_CLASS_NAMED("FritzVisionOutdoorSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionOutdoorSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionOutdoorSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Class labels for FritzVisionPeopleSegmentationModel
SWIFT_CLASS_NAMED("FritzVisionPeopleClass")
@interface FritzVisionPeopleClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationMediumClass")
@interface FritzVisionPeopleSegmentationMediumClass : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull none;)
+ (ModelSegmentationClass * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) ModelSegmentationClass * _Nonnull person;)
+ (ModelSegmentationClass * _Nonnull)person SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull allClasses;)
+ (NSArray<ModelSegmentationClass *> * _Nonnull)allClasses SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect people.
SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationMediumModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPeopleSegmentationMediumModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPeopleSegmentationMediumModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Image segmentation model to detect people.
SWIFT_CLASS_NAMED("FritzVisionPeopleSegmentationModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPeopleSegmentationModel : FritzVisionSegmentationModel
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel;
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPeopleSegmentationModel * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model name:(NSString * _Nonnull)name classes:(NSArray<ModelSegmentationClass *> * _Nonnull)classes managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


/// Model used to create a 3D pose from 2D pose
SWIFT_CLASS_NAMED("FritzVisionPoseLiftingModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseLiftingModel : BasePredictor
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzPose;
@class PoseLiftingPredictorOptions;
@class FritzPose3D;

SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseLiftingModel (SWIFT_EXTENSION(FritzVision))
/// Predict poses from an inputPose
/// \param input Input pose to process.
///
/// \param options The options used to configure the pose results.
///
/// \param completion Handler to call back on the main thread with poses or error.
///
- (void)predictWithImage:(FritzPose * _Nonnull)input options:(PoseLiftingPredictorOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzPose3D * _Nullable, NSError * _Nullable))completion;
@end

@class FritzVisionPoseModelOptions;
@class FritzVisionPoseResult;

/// A model used to predict the poses of people in images.
SWIFT_CLASS_NAMED("FritzVisionPoseModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseModel : BasePredictor
/// Model Configuration for pose model in Fritz.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) FritzModelConfiguration * _Nonnull modelConfig;)
+ (FritzModelConfiguration * _Nonnull)modelConfig SWIFT_WARN_UNUSED_RESULT;
+ (void)setModelConfig:(FritzModelConfiguration * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FritzManagedModel * _Nonnull managedModel;)
+ (FritzManagedModel * _Nonnull)managedModel SWIFT_WARN_UNUSED_RESULT;
/// Is WiFi required to download pose model over the air.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL wifiRequiredForModelDownload;)
+ (BOOL)wifiRequiredForModelDownload SWIFT_WARN_UNUSED_RESULT;
+ (void)setWifiRequiredForModelDownload:(BOOL)value;
/// Predict poses from a FritzImage.
/// \param input The image to use to dectect poses.
///
/// \param options The options used to configure the pose results.
///
/// \param completion Handler to call back on the main thread with poses or error.
///
- (void)predictWithImage:(FritzVisionImage * _Nonnull)input options:(FritzVisionPoseModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(FritzVisionPoseResult * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseModel (SWIFT_EXTENSION(FritzVision))
/// Fetch model. Downloads model if model has not been downloaded before.
/// \param completionHandler CompletionHandler called after fetchModel request finishes.
///
+ (void)fetchModelWithCompletionHandler:(void (^ _Nonnull)(FritzVisionPoseModel * _Nullable, NSError * _Nullable))completionHandler;
@end


/// Options for Pose Model.
SWIFT_CLASS_NAMED("FritzVisionPoseModelOptions")
@interface FritzVisionPoseModelOptions : NSObject
/// Crop and scale option. Default value is scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Minimum score a part must have to be included in a pose.
@property (nonatomic) double minPartThreshold;
/// Minimum score a pose must have to be included in results.
@property (nonatomic) double minPoseThreshold;
/// NMS radius for pose
@property (nonatomic) NSInteger nmsRadius;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@protocol MLFeatureProvider;

SWIFT_CLASS_NAMED("FritzVisionPoseResult") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseResult : NSObject
/// Model image width
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger modelInputWidth;)
+ (NSInteger)modelInputWidth SWIFT_WARN_UNUSED_RESULT;
/// Model image height
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger modelInputHeight;)
+ (NSInteger)modelInputHeight SWIFT_WARN_UNUSED_RESULT;
/// Original input image before it was rescaled
@property (nonatomic, readonly, strong) FritzVisionImage * _Nonnull image;
/// Pose model options.
@property (nonatomic, readonly, strong) FritzVisionPoseModelOptions * _Nonnull options;
/// Unavailable.  Use <code>FritzVisionPoseModel.predict</code> function to build.
- (nonnull instancetype)initForResults:(id <MLFeatureProvider> _Nonnull)results fritzImage:(FritzVisionImage * _Nonnull)fritzImage options:(FritzVisionPoseModelOptions * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionPoseResult (SWIFT_EXTENSION(FritzVision))
/// Decode single pose result
///
/// returns:
/// Pose
- (FritzPose * _Nullable)decodePose SWIFT_WARN_UNUSED_RESULT;
/// Draw single pose on input image.
///
/// returns:
/// UIImage if pose detected.
- (UIImage * _Nullable)drawPose SWIFT_WARN_UNUSED_RESULT;
/// Draw detected poses on input image.
/// \param pose List of poses to draw
///
///
/// returns:
/// Original image with poses drawn on image.
- (UIImage * _Nullable)drawPose:(FritzPose * _Nonnull)pose SWIFT_WARN_UNUSED_RESULT;
@end



SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionSegmentationModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionSegmentationModelOptions")
@interface FritzVisionSegmentationModelOptions : NSObject
/// Crop and scale option. Default value is scaleFit.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class MLMultiArray;

SWIFT_CLASS_NAMED("FritzVisionSegmentationResult") SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13)
@interface FritzVisionSegmentationResult : NSObject
/// Height of model output array.
@property (nonatomic, readonly) NSInteger height;
/// Width of model output array.
@property (nonatomic, readonly) NSInteger width;
/// Model classes.
@property (nonatomic, readonly, copy) NSArray<ModelSegmentationClass *> * _Nonnull classes;
/// Raw MLMultiArray result from prediction.
@property (nonatomic, readonly, strong) MLMultiArray * _Nonnull predictionResult;
/// Create 2D-Array same size as the model output with each point representing most likely class.
/// \param minThreshold Only include classes that have a probability greater than the minThreshold.
///
- (NSArray<NSNumber *> * _Nonnull)getMaxIndices:(double)minThreshold SWIFT_WARN_UNUSED_RESULT;
/// Generate UIImage mask from most likely class at each pixel.
/// The generated image size will fit the original image passed into prediction, applying rotation.  If the image was center cropped, will return an image that covers the cropped image.
/// \param minThreshold Minimum threshold value needed to count. By default zero.  You can set this property to filter out classes that may be the most likely but still have a lower probability.
///
/// \param alpha Alpha value of the color (0-255) for detected classes. By default completely opaque.
///
- (UIImage * _Nullable)toImageMask:(double)minThreshold alpha:(uint8_t)alpha SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSNumber *> * _Nonnull)thresholdClass:(ModelSegmentationClass * _Nonnull)segmentClass threshold:(double)threshold minAccepted:(double)minAccepted SWIFT_WARN_UNUSED_RESULT;
/// Generate UIImage mask of given class, filtering out values below threshold.
/// The generated image size will fit the original image passed into prediction, applying rotation.  If the image was center cropped, will return an image that covers the cropped image.
/// \param segmentClass Class to mask.
///
/// \param threshold Probability to filter.  Any probabilities below this value will be filtered out.
///
/// \param alpha Alpha value of the color (0-255) for detected classes.
///
/// \param minThresholdAccepted Any confidence score below this value will have an alpha of 0. Class confidence scores between <code>minThresholdAccepted</code> and <code>threshold</code> will retain their original value.
///
- (UIImage * _Nullable)toImageMask:(ModelSegmentationClass * _Nonnull)segmentClass threshold:(double)threshold alpha:(uint8_t)alpha minThresholdAccepted:(double)minThresholdAccepted SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class FritzVisionStyleModelOptions;

SWIFT_CLASS_NAMED("FritzVisionStyleModel") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel : NSObject
@property (nonatomic, readonly, strong) FritzManagedModel * _Nonnull managedModel;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nonnull instancetype)initWithIdentifiedModel:(id <FritzSwiftIdentifiedModel> _Nonnull)model;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model error:(NSError * _Nullable * _Nullable)error;
/// Initialize FritzStyleTransferModel with your own trained style model.
/// \param model Fritz model to use.
///
/// \param managedModel ManagedModel to use.
///
- (nullable instancetype)initWithFritzMLModel:(FritzMLModel * _Nonnull)model managedModel:(FritzManagedModel * _Nonnull)managedModel error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Run Style Transfer on a FritzVisionImage.
/// \param input Image or buffer to run model on.
///
/// \param options Options for model execution.
///
/// \param completion The block to invoke after the prediction request.  Contains a FritzVisionSegmentationResult or error message.
///
- (void)predict:(FritzVisionImage * _Nonnull)input options:(FritzVisionStyleModelOptions * _Nonnull)options completion:(SWIFT_NOESCAPE void (^ _Nonnull)(CVPixelBufferRef _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel (SWIFT_EXTENSION(FritzVision))
/// Fetch and load Style Models for the given tags.
/// Note that this instantiates all models which could cause memory pressure if you are loading many models.
/// If you do not want to immediately instantiate the models, create a ModelTagManager and manage loading yourself.
/// \param tags List of tags to load models for.
///
/// \param wifiRequiredForModelDownload If true, client must be connected to a wifi network to download a model. Default is false.
///
/// \param completionHandler Completion handler with instantiated FritzVisionStyleModels
///
+ (void)fetchStyleModelsForTags:(NSArray<NSString *> * _Nonnull)tags wifiRequiredForModelDownload:(BOOL)wifiRequiredForModelDownload withCompletionHandler:(void (^ _Nonnull)(NSArray<FritzVisionStyleModel *> * _Nullable, NSError * _Nullable))completionHandler;
@end


SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzVisionStyleModel (SWIFT_EXTENSION(FritzVision))
/// Model metadata set in webapp.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable metadata;
/// Model tags set in webapp.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable tags;
@end


SWIFT_CLASS_NAMED("FritzVisionStyleModelOptions")
@interface FritzVisionStyleModelOptions : NSObject
/// Crop and scale option.
@property (nonatomic) enum FritzVisionCropAndScale imageCropAndScaleOption;
/// Force predictions to use Core ML (if supported by model). In iOS 12, scaleFit
/// would incorrectly crop image.  When True (or on iOS 12) model will run using CoreML.
@property (nonatomic) BOOL forceCoreMLPrediction;
/// Resize the output to match the FritzVisionImage size.
@property (nonatomic) BOOL resizeOutputToInputDimensions;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FritzPosePoint;
enum PosePart : NSInteger;

/// Predicted keypoint containing part, score, and position identified.
SWIFT_CLASS_NAMED("Keypoint")
@interface FritzPoseKeypoint : NSObject
@property (nonatomic, readonly) NSInteger id;
@property (nonatomic, readonly, strong) FritzPosePoint * _Nonnull position;
@property (nonatomic, readonly) double score;
@property (nonatomic, readonly) enum PosePart part;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class Point3D;

/// Predicted keypoint containing part, score, and position identified.
SWIFT_CLASS_NAMED("Keypoint3D")
@interface FritzPoseKeypoint3D : NSObject
@property (nonatomic, readonly) NSInteger id;
@property (nonatomic, readonly, strong) Point3D * _Nonnull position;
@property (nonatomic, readonly) double score;
@property (nonatomic, readonly) enum PosePart part;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("ModelSegmentationClass")
@interface ModelSegmentationClass : NSObject
/// Index in output array from model.
@property (nonatomic, readonly) NSInteger index;
/// Label name for Model Segmentation Class.
@property (nonatomic, readonly, copy) NSString * _Nonnull label;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Predicted point on model input coordinates.
SWIFT_CLASS_NAMED("Point")
@interface FritzPosePoint : NSObject
@property (nonatomic, readonly) double x;
@property (nonatomic, readonly) double y;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end
















SWIFT_CLASS("_TtC11FritzVision7Point3D")
@interface Point3D : NSObject
@property (nonatomic, readonly) double x;
@property (nonatomic, readonly) double y;
@property (nonatomic, readonly) double z;
- (nonnull instancetype)initWithX:(double)x y:(double)y z:(double)z OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (NSArray<NSNumber *> * _Nonnull)toArray SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface Point3D (SWIFT_EXTENSION(FritzVision))
- (nonnull instancetype)initWith:(NSArray<NSNumber *> * _Nonnull)array;
@end






/// Detected pose with Keypoints and corresponding score.
SWIFT_CLASS_NAMED("Pose") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzPose : NSObject
@property (nonatomic, readonly, copy) NSArray<FritzPoseKeypoint *> * _Nonnull keypoints;
@property (nonatomic, readonly) double score;
/// Create new Pose with keypoint positions scaled to be inside of rect.
/// \param rect Rect coordinates
///
///
/// returns:
/// New Pose with position inset in provided rect
- (FritzPose * _Nonnull)inRect:(CGRect)rect SWIFT_WARN_UNUSED_RESULT;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end






/// Detected pose with Keypoints and corresponding score.
SWIFT_CLASS_NAMED("Pose3D") SWIFT_AVAILABILITY(ios,introduced=11.0)
@interface FritzPose3D : NSObject
@property (nonatomic, readonly, copy) NSArray<FritzPoseKeypoint3D *> * _Nonnull keypoints;
@property (nonatomic, readonly) double score;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end






/// Options for Pose Model.
SWIFT_CLASS("_TtC11FritzVision27PoseLiftingPredictorOptions")
@interface PoseLiftingPredictorOptions : NSObject
/// Default Pose model options.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) PoseLiftingPredictorOptions * _Nonnull defaults;)
+ (PoseLiftingPredictorOptions * _Nonnull)defaults SWIFT_WARN_UNUSED_RESULT;
/// If true only uses CPU to run predictions.
@property (nonatomic) BOOL useCPUOnly;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, PosePart, closed) {
  PosePartNose = 0,
  PosePartLeftEye = 1,
  PosePartRightEye = 2,
  PosePartLeftEar = 3,
  PosePartRightEar = 4,
  PosePartLeftShoulder = 5,
  PosePartRightShoulder = 6,
  PosePartLeftElbow = 7,
  PosePartRightElbow = 8,
  PosePartLeftWrist = 9,
  PosePartRightWrist = 10,
  PosePartLeftHip = 11,
  PosePartRightHip = 12,
  PosePartLeftKnee = 13,
  PosePartRightKnee = 14,
  PosePartLeftAnkle = 15,
  PosePartRightAnkle = 16,
};





#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#endif
#endif
